/* Generated by re2c 0.9.1-C on Tue Jul 14 16:13:36 2009
 */
#line 1 "./modules/parsers/gas/gas-token.re"
/*
 * GAS-compatible re2c lexer
 *
 *  Copyright (C) 2005-2007  Peter Johnson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of other contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND OTHER CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR OTHER CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <util.h>
RCSID("$Id: gas-token.re 2166 2009-01-02 08:33:21Z peter $");

#include <libyasm.h>

#include "modules/parsers/gas/gas-parser.h"


#define BSIZE   8192

#define YYCURSOR        cursor
#define YYLIMIT         (s->lim)
#define YYMARKER        (s->ptr)
#define YYFILL(n)       {cursor = fill(parser_gas, cursor);}

#define RETURN(i)       do {s->cur = cursor; parser_gas->tokch = s->tok[0]; \
                         return i;} while (0)

#define SCANINIT()      {s->tok = cursor;}

#define TOK             ((char *)s->tok)
#define TOKLEN          (size_t)(cursor-s->tok)

static size_t
rept_input(yasm_parser_gas *parser_gas, /*@out@*/ YYCTYPE *buf,
           size_t max_size)
{
    gas_rept *rept = parser_gas->rept;
    size_t numleft = max_size;
    YYCTYPE *bufp = buf;

    /* If numrept is 0, copy out just the line end characters */
    if (rept->numrept == 0) {
        /* Skip first line, which contains .line */
        rept->line = STAILQ_NEXT(rept->line, link);
        if (!rept->line) {
            rept->numrept = 1;
            rept->numdone = 1;
        }
        while (rept->numrept == 0 && numleft > 0) {
            *bufp++ = rept->line->data[rept->line->len-1];
            rept->line = STAILQ_NEXT(rept->line, link);
            if (!rept->line) {
                rept->numrept = 1;
                rept->numdone = 1;
            }
        }
    }

    /* Copy out the previous fill buffer until we're *really* done */
    if (rept->numdone == rept->numrept) {
        size_t numcopy = rept->oldbuflen - rept->oldbufpos;
        if (numcopy > numleft)
            numcopy = numleft;
        memcpy(bufp, &rept->oldbuf[rept->oldbufpos], numcopy);
        numleft -= numcopy;
        bufp += numcopy;
        rept->oldbufpos += numcopy;

        if (rept->oldbufpos == rept->oldbuflen) {
            /* Delete lines, then delete rept and clear rept state */
            gas_rept_line *cur, *next;
            cur = STAILQ_FIRST(&rept->lines);
            while (cur) {
                next = STAILQ_NEXT(cur, link);
                yasm_xfree(cur->data);
                yasm_xfree(cur);
                cur = next;
            }
            yasm_xfree(rept->oldbuf);
            yasm_xfree(rept);
            parser_gas->rept = NULL;
        }
    }

    while (numleft > 0 && rept->numdone < rept->numrept) {
        /* Copy from line data to buf */
        size_t numcopy = rept->line->len - rept->linepos;
        if (numcopy > numleft)
            numcopy = numleft;
        memcpy(bufp, &rept->line->data[rept->linepos], numcopy);
        numleft -= numcopy;
        bufp += numcopy;
        rept->linepos += numcopy;

        /* Update locations if needed */
        if (rept->linepos == rept->line->len) {
            rept->line = STAILQ_NEXT(rept->line, link);
            rept->linepos = 0;
        }
        if (rept->line == NULL) {
            rept->numdone++;
            rept->line = STAILQ_FIRST(&rept->lines);
        }
    }

    return (max_size-numleft);
}

/* Bridge function to convert byte-oriented parser with line-oriented
 * preprocessor.
 */
static size_t
preproc_input(yasm_parser_gas *parser_gas, /*@out@*/ YYCTYPE *buf,
              size_t max_size)
{
    size_t tot=0;
    while (max_size > 0) {
        size_t n;

        if (!parser_gas->line) {
            parser_gas->line = yasm_preproc_get_line(parser_gas->preproc);
            if (!parser_gas->line)
                return tot; /* EOF */
            parser_gas->linepos = parser_gas->line;
            parser_gas->lineleft = strlen(parser_gas->line) + 1;
            parser_gas->line[parser_gas->lineleft-1] = '\n';
        }

        n = parser_gas->lineleft<max_size ? parser_gas->lineleft : max_size;
        strncpy((char *)buf+tot, parser_gas->linepos, n);

        if (n == parser_gas->lineleft) {
            yasm_xfree(parser_gas->line);
            parser_gas->line = NULL;
        } else {
            parser_gas->lineleft -= n;
            parser_gas->linepos += n;
        }

        tot += n;
        max_size -= n;
    }
    return tot;
}
#if 0
static size_t
fill_input(void *d, unsigned char *buf, size_t max)
{
    return yasm_preproc_input((yasm_preproc *)d, (char *)buf, max);
}
#endif
static YYCTYPE *
fill(yasm_parser_gas *parser_gas, YYCTYPE *cursor)
{
    yasm_scanner *s = &parser_gas->s;
    int first = 0;
    if(!s->eof){
        size_t cnt = s->tok - s->bot;
        if(cnt){
            memmove(s->bot, s->tok, (size_t)(s->lim - s->tok));
            s->tok = s->bot;
            s->ptr -= cnt;
            cursor -= cnt;
            s->lim -= cnt;
        }
        if (!s->bot)
            first = 1;
        if((s->top - s->lim) < BSIZE){
            YYCTYPE *buf = yasm_xmalloc((size_t)(s->lim - s->bot) + BSIZE);
            memcpy(buf, s->tok, (size_t)(s->lim - s->tok));
            s->tok = buf;
            s->ptr = &buf[s->ptr - s->bot];
            cursor = &buf[cursor - s->bot];
            s->lim = &buf[s->lim - s->bot];
            s->top = &s->lim[BSIZE];
            if (s->bot)
                yasm_xfree(s->bot);
            s->bot = buf;
        }
        if (parser_gas->rept && parser_gas->rept->ended) {
            /* Pull from rept lines instead of preproc */
            cnt = rept_input(parser_gas, s->lim, BSIZE);
        } else if((cnt = preproc_input(parser_gas, s->lim, BSIZE)) == 0) {
            s->eof = &s->lim[cnt]; *s->eof++ = '\n';
        }
        s->lim += cnt;
        if (first && parser_gas->save_input) {
            int i;
            YYCTYPE *saveline;
            parser_gas->save_last ^= 1;
            saveline = parser_gas->save_line[parser_gas->save_last];
            /* save next line into cur_line */
            for (i=0; i<79 && &s->tok[i] < s->lim && s->tok[i] != '\n'; i++)
                saveline[i] = s->tok[i];
            saveline[i] = '\0';
        }
    }
    return cursor;
}

static YYCTYPE *
save_line(yasm_parser_gas *parser_gas, YYCTYPE *cursor)
{
    yasm_scanner *s = &parser_gas->s;
    int i = 0;
    YYCTYPE *saveline;

    parser_gas->save_last ^= 1;
    saveline = parser_gas->save_line[parser_gas->save_last];

    /* save next line into cur_line */
    if ((YYLIMIT - YYCURSOR) < 80)
        YYFILL(80);
    for (i=0; i<79 && &cursor[i] < s->lim && cursor[i] != '\n'; i++)
        saveline[i] = cursor[i];
    saveline[i] = '\0';
    return cursor;
}

/* starting size of string buffer */
#define STRBUF_ALLOC_SIZE       128

/* string buffer used when parsing strings/character constants */
static YYCTYPE *strbuf = NULL;

/* length of strbuf (including terminating NULL character) */
static size_t strbuf_size = 0;

static void
strbuf_append(size_t count, YYCTYPE *cursor, yasm_scanner *s, int ch)
{
    if (count >= strbuf_size) {
        strbuf = yasm_xrealloc(strbuf, strbuf_size + STRBUF_ALLOC_SIZE);
        strbuf_size += STRBUF_ALLOC_SIZE;
    }
    strbuf[count] = ch;
}

#line 268 "./modules/parsers/gas/gas-token.re"



int
gas_parser_lex(YYSTYPE *lvalp, yasm_parser_gas *parser_gas)
{
    /*@null@*/ gas_rept *rept = parser_gas->rept;
    yasm_scanner *s = &parser_gas->s;
    YYCTYPE *cursor = s->cur;
    size_t count;
    YYCTYPE savech;
    int linestart;
    gas_rept_line *new_line;

    /* Handle one token of lookahead */
    if (parser_gas->peek_token != NONE) {
        int tok = parser_gas->peek_token;
        *lvalp = parser_gas->peek_tokval;  /* structure copy */
        parser_gas->tokch = parser_gas->peek_tokch;
        parser_gas->peek_token = NONE;
        return tok;
    }

    /* Catch EOF */
    if (s->eof && cursor == s->eof)
        return 0;

    /* Handle rept */
    if (rept && !rept->ended)
        goto rept_directive;

    /* Jump to proper "exclusive" states */
    switch (parser_gas->state) {
        case COMMENT:
            goto comment;
        case SECTION_DIRECTIVE:
            goto section_directive;
        case NASM_FILENAME:
            goto nasm_filename;
        default:
            break;
    }

scan:
    SCANINIT();

    {
	static unsigned char yybm[] = {
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   1,   0,   0,   0,   1,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  1,   0,   0,   0,  12,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,  12,   0, 
	254, 254, 126, 126, 126, 126, 126, 126, 
	 94,  94,   0,   0,   0,   0,   0,   0, 
	  8,  78,  78,  78,  78,  78,  78,  14, 
	 14,  14,  14,  14,  14,  14,  14,  14, 
	 14,  14,  14,  14,  14,  14,  14,  14, 
	 14,  14,  14,   0,   0,   0,   0,  12, 
	  0,  78,  78,  78,  78,  78,  78,  14, 
	 14,  14,  14,  14,  14,  14,  14,  14, 
	 14,  14,  14,  14,  14,  14,  14,  14, 
	 14,  14,  14,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	};

#line 345 "gas-token.c"
{
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy0;
	++YYCURSOR;
yy0:
	if((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	if(yych <= '/'){
		if(yych <= '#'){
			if(yych <= '\r'){
				if(yych <= '\t'){
					if(yych <= '\b')	goto yy30;
					goto yy26;
				} else {
					if(yych <= '\n')	goto yy28;
					if(yych <= '\f')	goto yy30;
					goto yy26;
				}
			} else {
				if(yych <= ' '){
					if(yych <= '\037')	goto yy30;
					goto yy26;
				} else {
					if(yych <= '!')	goto yy17;
					if(yych <= '"')	goto yy11;
					goto yy24;
				}
			}
		} else {
			if(yych <= '*'){
				if(yych <= '%'){
					if(yych <= '$')	goto yy17;
					goto yy22;
				} else {
					if(yych == '\'')	goto yy9;
					goto yy17;
				}
			} else {
				if(yych <= ','){
					if(yych <= '+')	goto yy5;
					goto yy17;
				} else {
					if(yych <= '-')	goto yy5;
					if(yych <= '.')	goto yy7;
					goto yy18;
				}
			}
		}
	} else {
		if(yych <= 'Z'){
			if(yych <= '<'){
				if(yych <= '9'){
					if(yych >= '1')	goto yy4;
					goto yy2;
				} else {
					if(yych <= ':')	goto yy17;
					if(yych <= ';')	goto yy19;
					goto yy13;
				}
			} else {
				if(yych <= '>'){
					if(yych <= '=')	goto yy17;
					goto yy15;
				} else {
					if(yych <= '?')	goto yy30;
					if(yych <= '@')	goto yy17;
					goto yy21;
				}
			}
		} else {
			if(yych <= 'z'){
				if(yych <= '^'){
					if(yych <= ']')	goto yy30;
					goto yy17;
				} else {
					if(yych == '`')	goto yy30;
					goto yy21;
				}
			} else {
				if(yych <= '|'){
					if(yych <= '{')	goto yy30;
					goto yy17;
				} else {
					if(yych == '~')	goto yy17;
					goto yy30;
				}
			}
		}
	}
yy2:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'T'){
		if(yych <= 'A'){
			if(yych <= '/'){
				if(yych == '.')	goto yy88;
				goto yy3;
			} else {
				if(yych <= '9')	goto yy88;
				if(yych <= ':')	goto yy79;
				goto yy3;
			}
		} else {
			if(yych <= 'E'){
				if(yych <= 'B')	goto yy83;
				if(yych >= 'D')	goto yy86;
				goto yy3;
			} else {
				if(yych <= 'F')	goto yy84;
				if(yych >= 'T')	goto yy86;
				goto yy3;
			}
		}
	} else {
		if(yych <= 'e'){
			if(yych <= 'a'){
				if(yych == 'X')	goto yy90;
				goto yy3;
			} else {
				if(yych <= 'b')	goto yy83;
				if(yych >= 'd')	goto yy86;
				goto yy3;
			}
		} else {
			if(yych <= 't'){
				if(yych <= 'f')	goto yy84;
				if(yych >= 't')	goto yy86;
				goto yy3;
			} else {
				if(yych == 'x')	goto yy90;
				goto yy3;
			}
		}
	}
yy3:
#line 316 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->intn = yasm_intnum_create_dec(TOK);
            s->tok[TOKLEN] = savech;
            RETURN(INTNUM);
        }
#line 489 "gas-token.c"
yy4:	yych = *++YYCURSOR;
	if(yych <= 'E'){
		if(yych <= ':'){
			if(yych <= '9')	goto yy82;
			goto yy79;
		} else {
			if(yych == 'B')	goto yy75;
			goto yy82;
		}
	} else {
		if(yych <= 'b'){
			if(yych <= 'F')	goto yy77;
			if(yych <= 'a')	goto yy82;
			goto yy75;
		} else {
			if(yych == 'f')	goto yy77;
			goto yy82;
		}
	}
yy5:	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == '.')	goto yy59;
	if(yych <= '/')	goto yy6;
	if(yych <= '9')	goto yy57;
	goto yy6;
yy6:
#line 390 "./modules/parsers/gas/gas-token.re"
{ RETURN(s->tok[0]); }
#line 518 "gas-token.c"
yy7:	yych = *++YYCURSOR;
	if(yybm[0+yych] & 16) {
		goto yy47;
	}
	goto yy37;
yy8:
#line 397 "./modules/parsers/gas/gas-token.re"
{
            lvalp->str.contents = yasm__xstrndup(TOK, TOKLEN);
            lvalp->str.len = TOKLEN;
            RETURN(ID);
        }
#line 531 "gas-token.c"
yy9:	yych = *++YYCURSOR;
	goto yy10;
yy10:
#line 376 "./modules/parsers/gas/gas-token.re"
{
            goto charconst;
        }
#line 539 "gas-token.c"
yy11:	yych = *++YYCURSOR;
	goto yy12;
yy12:
#line 381 "./modules/parsers/gas/gas-token.re"
{
            goto stringconst;
        }
#line 547 "gas-token.c"
yy13:	yych = *++YYCURSOR;
	if(yych == '<')	goto yy45;
	goto yy14;
yy14:
#line 388 "./modules/parsers/gas/gas-token.re"
{ RETURN(LEFT_OP); }
#line 554 "gas-token.c"
yy15:	yych = *++YYCURSOR;
	if(yych == '>')	goto yy43;
	goto yy16;
yy16:
#line 389 "./modules/parsers/gas/gas-token.re"
{ RETURN(RIGHT_OP); }
#line 561 "gas-token.c"
yy17:	yych = *++YYCURSOR;
	goto yy6;
yy18:	yych = *++YYCURSOR;
	if(yych == '*')	goto yy41;
	goto yy6;
yy19:	yych = *++YYCURSOR;
	goto yy20;
yy20:
#line 391 "./modules/parsers/gas/gas-token.re"
{
            parser_gas->state = INITIAL;
            RETURN(s->tok[0]);
        }
#line 575 "gas-token.c"
yy21:	yych = *++YYCURSOR;
	goto yy37;
yy22:	yych = *++YYCURSOR;
	if(yybm[0+yych] & 2) {
		goto yy33;
	}
	goto yy23;
yy23:
#line 493 "./modules/parsers/gas/gas-token.re"
{
            yasm_warn_set(YASM_WARN_UNREC_CHAR,
                          N_("ignoring unrecognized character `%s'"),
                          yasm__conv_unprint(s->tok[0]));
            goto scan;
        }
#line 591 "gas-token.c"
yy24:	yych = *++YYCURSOR;
	goto yy25;
yy25:
#line 476 "./modules/parsers/gas/gas-token.re"
{
            if (parser_gas->is_cpp_preproc)
            {
                RETURN(CPP_LINE_MARKER);
            } else
                goto line_comment;
        }
#line 603 "gas-token.c"
yy26:	yych = *++YYCURSOR;
	goto yy32;
yy27:
#line 484 "./modules/parsers/gas/gas-token.re"
{ goto scan; }
#line 609 "gas-token.c"
yy28:	yych = *++YYCURSOR;
	goto yy29;
yy29:
#line 486 "./modules/parsers/gas/gas-token.re"
{
            if (parser_gas->save_input)
                cursor = save_line(parser_gas, cursor);
            parser_gas->state = INITIAL;
            RETURN(s->tok[0]);
        }
#line 620 "gas-token.c"
yy30:	yych = *++YYCURSOR;
	goto yy23;
yy31:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy32;
yy32:	if(yybm[0+yych] & 1) {
		goto yy31;
	}
	goto yy27;
yy33:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy34;
yy34:	if(yybm[0+yych] & 2) {
		goto yy33;
	}
	goto yy35;
yy35:
#line 414 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            if (parser_gas->is_nasm_preproc && strcmp(TOK+1, "line") == 0) {
                s->tok[TOKLEN] = savech;
                RETURN(NASM_LINE_MARKER);
            }

            switch (yasm_arch_parse_check_regtmod
                    (p_object->arch, TOK+1, TOKLEN-1, &lvalp->arch_data)) {
                case YASM_ARCH_REG:
                    s->tok[TOKLEN] = savech;
                    RETURN(REG);
                case YASM_ARCH_REGGROUP:
                    s->tok[TOKLEN] = savech;
                    RETURN(REGGROUP);
                case YASM_ARCH_SEGREG:
                    s->tok[TOKLEN] = savech;
                    RETURN(SEGREG);
                default:
                    break;
            }
            yasm_error_set(YASM_ERROR_GENERAL,
                           N_("Unrecognized register name `%s'"), s->tok);
            s->tok[TOKLEN] = savech;
            lvalp->arch_data = 0;
            RETURN(REG);
        }
#line 669 "gas-token.c"
yy36:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy37;
yy37:	if(yybm[0+yych] & 4) {
		goto yy36;
	}
	if(yych != '@')	goto yy8;
	goto yy38;
yy38:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy39;
yy39:	if(yybm[0+yych] & 8) {
		goto yy38;
	}
	goto yy40;
yy40:
#line 404 "./modules/parsers/gas/gas-token.re"
{
            /* if @ not part of ID, move the scanner cursor to the first @ */
            if (!((yasm_objfmt_base *)p_object->objfmt)->module->id_at_ok)
                cursor = (unsigned char *)strchr(TOK, '@');
            lvalp->str.contents = yasm__xstrndup(TOK, TOKLEN);
            lvalp->str.len = TOKLEN;
            RETURN(ID);
        }
#line 697 "gas-token.c"
yy41:	yych = *++YYCURSOR;
	goto yy42;
yy42:
#line 475 "./modules/parsers/gas/gas-token.re"
{ parser_gas->state = COMMENT; goto comment; }
#line 703 "gas-token.c"
yy43:	yych = *++YYCURSOR;
	goto yy44;
yy44:
#line 387 "./modules/parsers/gas/gas-token.re"
{ RETURN(RIGHT_OP); }
#line 709 "gas-token.c"
yy45:	yych = *++YYCURSOR;
	goto yy46;
yy46:
#line 386 "./modules/parsers/gas/gas-token.re"
{ RETURN(LEFT_OP); }
#line 715 "gas-token.c"
yy47:	++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	goto yy48;
yy48:	if(yybm[0+yych] & 16) {
		goto yy47;
	}
	if(yych <= 'E'){
		if(yych <= '.'){
			if(yych == '$')	goto yy36;
			if(yych >= '.')	goto yy36;
			goto yy49;
		} else {
			if(yych <= '?')	goto yy49;
			if(yych <= '@')	goto yy38;
			if(yych <= 'D')	goto yy36;
			goto yy50;
		}
	} else {
		if(yych <= '`'){
			if(yych <= 'Z')	goto yy36;
			if(yych == '_')	goto yy36;
			goto yy49;
		} else {
			if(yych == 'e')	goto yy50;
			if(yych <= 'z')	goto yy36;
			goto yy49;
		}
	}
yy49:
#line 353 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->flt = yasm_floatnum_create(TOK);
            s->tok[TOKLEN] = savech;
            RETURN(FLTNUM);
        }
#line 754 "gas-token.c"
yy50:	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= ','){
		if(yych == '+')	goto yy53;
		goto yy37;
	} else {
		if(yych <= '-')	goto yy53;
		if(yych <= '/')	goto yy37;
		if(yych >= ':')	goto yy37;
		goto yy51;
	}
yy51:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy52;
yy52:	if(yych <= '?'){
		if(yych <= '-'){
			if(yych == '$')	goto yy36;
			goto yy49;
		} else {
			if(yych <= '.')	goto yy36;
			if(yych <= '/')	goto yy49;
			if(yych <= '9')	goto yy51;
			goto yy49;
		}
	} else {
		if(yych <= '^'){
			if(yych <= '@')	goto yy38;
			if(yych <= 'Z')	goto yy36;
			goto yy49;
		} else {
			if(yych == '`')	goto yy49;
			if(yych <= 'z')	goto yy36;
			goto yy49;
		}
	}
yy53:	yych = *++YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych <= '9')	goto yy55;
	goto yy54;
yy54:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 0:	goto yy3;
	case 6:	goto yy89;
	case 3:	goto yy49;
	case 4:	goto yy64;
	case 5:	goto yy85;
	case 1:	goto yy6;
	case 2:	goto yy8;
	}
yy55:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy56;
yy56:	if(yych <= '/')	goto yy49;
	if(yych <= '9')	goto yy55;
	goto yy49;
yy57:	++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	goto yy58;
yy58:	if(yych == '.')	goto yy63;
	if(yych <= '/')	goto yy54;
	if(yych <= '9')	goto yy57;
	goto yy54;
yy59:	yych = *++YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych >= ':')	goto yy54;
	goto yy60;
yy60:	yyaccept = 3;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	goto yy61;
yy61:	if(yych <= 'D'){
		if(yych <= '/')	goto yy49;
		if(yych <= '9')	goto yy60;
		goto yy49;
	} else {
		if(yych <= 'E')	goto yy62;
		if(yych != 'e')	goto yy49;
		goto yy62;
	}
yy62:	yych = *++YYCURSOR;
	if(yych <= ','){
		if(yych == '+')	goto yy53;
		goto yy54;
	} else {
		if(yych <= '-')	goto yy53;
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy55;
		goto yy54;
	}
yy63:	yyaccept = 4;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'D'){
		if(yych <= '/')	goto yy64;
		if(yych <= '9')	goto yy65;
		goto yy64;
	} else {
		if(yych <= 'E')	goto yy67;
		if(yych == 'e')	goto yy67;
		goto yy64;
	}
yy64:
#line 360 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->flt = yasm_floatnum_create(TOK);
            s->tok[TOKLEN] = savech;
            RETURN(FLTNUM);
        }
#line 868 "gas-token.c"
yy65:	yyaccept = 3;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	goto yy66;
yy66:	if(yych <= 'D'){
		if(yych <= '/')	goto yy49;
		if(yych <= '9')	goto yy65;
		goto yy49;
	} else {
		if(yych <= 'E')	goto yy71;
		if(yych == 'e')	goto yy71;
		goto yy49;
	}
yy67:	yych = *++YYCURSOR;
	if(yych <= ','){
		if(yych != '+')	goto yy54;
		goto yy68;
	} else {
		if(yych <= '-')	goto yy68;
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy69;
		goto yy54;
	}
yy68:	yych = *++YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych >= ':')	goto yy54;
	goto yy69;
yy69:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy70;
yy70:	if(yych <= '/')	goto yy64;
	if(yych <= '9')	goto yy69;
	goto yy64;
yy71:	yych = *++YYCURSOR;
	if(yych <= ','){
		if(yych != '+')	goto yy54;
		goto yy72;
	} else {
		if(yych <= '-')	goto yy72;
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy73;
		goto yy54;
	}
yy72:	yych = *++YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych >= ':')	goto yy54;
	goto yy73;
yy73:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy74;
yy74:	if(yych <= '/')	goto yy49;
	if(yych <= '9')	goto yy73;
	goto yy49;
yy75:	yych = *++YYCURSOR;
	goto yy76;
yy76:
#line 466 "./modules/parsers/gas/gas-token.re"
{
            /* build local label name */
            lvalp->str.contents = yasm_xmalloc(30);
            lvalp->str.len =
                sprintf(lvalp->str.contents, "L%c\001%lu", s->tok[0],
                        parser_gas->local[s->tok[0]-'0']);
            RETURN(ID);
        }
#line 937 "gas-token.c"
yy77:	yych = *++YYCURSOR;
	goto yy78;
yy78:
#line 456 "./modules/parsers/gas/gas-token.re"
{
            /* build local label name */
            lvalp->str.contents = yasm_xmalloc(30);
            lvalp->str.len =
                sprintf(lvalp->str.contents, "L%c\001%lu", s->tok[0],
                        parser_gas->local[s->tok[0]-'0']+1);
            RETURN(ID);
        }
#line 950 "gas-token.c"
yy79:	yych = *++YYCURSOR;
	goto yy80;
yy80:
#line 444 "./modules/parsers/gas/gas-token.re"
{
            /* increment label index */
            parser_gas->local[s->tok[0]-'0']++;
            /* build local label name */
            lvalp->str.contents = yasm_xmalloc(30);
            lvalp->str.len =
                sprintf(lvalp->str.contents, "L%c\001%lu", s->tok[0],
                        parser_gas->local[s->tok[0]-'0']);
            RETURN(LABEL);
        }
#line 965 "gas-token.c"
yy81:	++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	goto yy82;
yy82:	if(yych == '.')	goto yy63;
	if(yych <= '/')	goto yy3;
	if(yych <= '9')	goto yy81;
	goto yy3;
yy83:	yych = *++YYCURSOR;
	if(yybm[0+yych] & 128) {
		goto yy102;
	}
	goto yy76;
yy84:	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == '+')	goto yy94;
	if(yych == '-')	goto yy94;
	goto yy95;
yy85:
#line 367 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->flt = yasm_floatnum_create(TOK+2);
            s->tok[TOKLEN] = savech;
            RETURN(FLTNUM);
        }
#line 993 "gas-token.c"
yy86:	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == '+')	goto yy94;
	if(yych == '-')	goto yy94;
	goto yy95;
yy87:	yyaccept = 6;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	goto yy88;
yy88:	if(yybm[0+yych] & 32) {
		goto yy87;
	}
	if(yych == '.')	goto yy63;
	if(yych <= '/')	goto yy89;
	if(yych <= '9')	goto yy57;
	goto yy89;
yy89:
#line 334 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->intn = yasm_intnum_create_oct(TOK);
            s->tok[TOKLEN] = savech;
            RETURN(INTNUM);
        }
#line 1020 "gas-token.c"
yy90:	yych = *++YYCURSOR;
	if(yybm[0+yych] & 64) {
		goto yy91;
	}
	goto yy54;
yy91:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy92;
yy92:	if(yybm[0+yych] & 64) {
		goto yy91;
	}
	goto yy93;
yy93:
#line 343 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            /* skip 0 and x */
            lvalp->intn = yasm_intnum_create_hex(TOK+2);
            s->tok[TOKLEN] = savech;
            RETURN(INTNUM);
        }
#line 1044 "gas-token.c"
yy94:	yyaccept = 5;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	goto yy95;
yy95:	if(yych <= '9'){
		if(yych == '.')	goto yy96;
		if(yych <= '/')	goto yy85;
		goto yy94;
	} else {
		if(yych <= 'E'){
			if(yych <= 'D')	goto yy85;
			goto yy98;
		} else {
			if(yych == 'e')	goto yy98;
			goto yy85;
		}
	}
yy96:	yyaccept = 5;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	goto yy97;
yy97:	if(yych <= 'D'){
		if(yych <= '/')	goto yy85;
		if(yych <= '9')	goto yy96;
		goto yy85;
	} else {
		if(yych <= 'E')	goto yy98;
		if(yych != 'e')	goto yy85;
		goto yy98;
	}
yy98:	yych = *++YYCURSOR;
	if(yych <= ','){
		if(yych != '+')	goto yy54;
		goto yy99;
	} else {
		if(yych <= '-')	goto yy99;
		if(yych <= '/')	goto yy54;
		if(yych <= '9')	goto yy100;
		goto yy54;
	}
yy99:	yych = *++YYCURSOR;
	if(yych <= '/')	goto yy54;
	if(yych >= ':')	goto yy54;
	goto yy100;
yy100:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy101;
yy101:	if(yych <= '/')	goto yy85;
	if(yych <= '9')	goto yy100;
	goto yy85;
yy102:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy103;
yy103:	if(yybm[0+yych] & 128) {
		goto yy102;
	}
	goto yy104;
yy104:
#line 325 "./modules/parsers/gas/gas-token.re"
{
            savech = s->tok[TOKLEN];
            s->tok[TOKLEN] = '\0';
            lvalp->intn = yasm_intnum_create_bin(TOK+2);
            s->tok[TOKLEN] = savech;
            RETURN(INTNUM);
        }
#line 1115 "gas-token.c"
}
}
#line 499 "./modules/parsers/gas/gas-token.re"


    /* C-style comment; nesting not supported */
comment:
    SCANINIT();

    {

#line 1127 "gas-token.c"
{
	YYCTYPE yych;
	goto yy105;
	++YYCURSOR;
yy105:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych == '\n')	goto yy109;
	if(yych != '*')	goto yy111;
	goto yy107;
yy107:	yych = *++YYCURSOR;
	if(yych == '/')	goto yy112;
	goto yy108;
yy108:
#line 515 "./modules/parsers/gas/gas-token.re"
{
            if (cursor == s->eof)
                return 0;
            goto comment;
        }
#line 1148 "gas-token.c"
yy109:	yych = *++YYCURSOR;
	goto yy110;
yy110:
#line 509 "./modules/parsers/gas/gas-token.re"
{
            if (parser_gas->save_input)
                cursor = save_line(parser_gas, cursor);
            RETURN(s->tok[0]);
        }
#line 1158 "gas-token.c"
yy111:	yych = *++YYCURSOR;
	goto yy108;
yy112:	yych = *++YYCURSOR;
	goto yy113;
yy113:
#line 507 "./modules/parsers/gas/gas-token.re"
{ parser_gas->state = INITIAL; goto scan; }
#line 1166 "gas-token.c"
}
}
#line 520 "./modules/parsers/gas/gas-token.re"


    /* Single line comment. */
line_comment:
    {
	static unsigned char yybm[] = {
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128,   0, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	};

#line 1210 "gas-token.c"
{
	YYCTYPE yych;
	goto yy114;
yy115:	++YYCURSOR;
yy114:
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy116;
yy116:	if(yybm[0+yych] & 128) {
		goto yy115;
	}
	goto yy117;
yy117:
#line 525 "./modules/parsers/gas/gas-token.re"
{ goto scan; }
#line 1226 "gas-token.c"
}
}
#line 526 "./modules/parsers/gas/gas-token.re"


    /* .section directive (the section name portion thereof) */
section_directive:
    SCANINIT();

    {
	static unsigned char yybm[] = {
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,  64,   0,   0,   0,  64,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	 64,   0,   0,   0, 128,   0,   0,   0, 
	  0,   0,   0,   0,   0, 128, 128,   0, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128,   0,   0,   0,   0,   0,   0, 
	  0, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128,   0,   0,   0,   0, 128, 
	  0, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	};

#line 1272 "gas-token.c"
{
	YYCTYPE yych;
	goto yy118;
	++YYCURSOR;
yy118:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych <= '$'){
		if(yych <= '\r'){
			if(yych <= '\t'){
				if(yych <= '\b')	goto yy130;
				goto yy124;
			} else {
				if(yych <= '\n')	goto yy128;
				if(yych <= '\f')	goto yy130;
				goto yy124;
			}
		} else {
			if(yych <= '!'){
				if(yych == ' ')	goto yy124;
				goto yy130;
			} else {
				if(yych <= '"')	goto yy122;
				if(yych <= '#')	goto yy130;
				goto yy120;
			}
		}
	} else {
		if(yych <= '@'){
			if(yych <= '.'){
				if(yych <= '+')	goto yy130;
				if(yych <= ',')	goto yy126;
				goto yy120;
			} else {
				if(yych <= '/')	goto yy130;
				if(yych >= ':')	goto yy130;
				goto yy120;
			}
		} else {
			if(yych <= '_'){
				if(yych <= 'Z')	goto yy120;
				if(yych <= '^')	goto yy130;
				goto yy120;
			} else {
				if(yych <= '`')	goto yy130;
				if(yych >= '{')	goto yy130;
				goto yy120;
			}
		}
	}
yy120:	yych = *++YYCURSOR;
	goto yy135;
yy121:
#line 533 "./modules/parsers/gas/gas-token.re"
{
            lvalp->str.contents = yasm__xstrndup(TOK, TOKLEN);
            lvalp->str.len = TOKLEN;
            parser_gas->state = INITIAL;
            RETURN(ID);
        }
#line 1333 "gas-token.c"
yy122:	yych = *++YYCURSOR;
	goto yy123;
yy123:
#line 540 "./modules/parsers/gas/gas-token.re"
{ goto stringconst; }
#line 1339 "gas-token.c"
yy124:	yych = *++YYCURSOR;
	goto yy133;
yy125:
#line 542 "./modules/parsers/gas/gas-token.re"
{ goto section_directive; }
#line 1345 "gas-token.c"
yy126:	yych = *++YYCURSOR;
	goto yy127;
yy127:
#line 544 "./modules/parsers/gas/gas-token.re"
{
            parser_gas->state = INITIAL;
            RETURN(s->tok[0]);
        }
#line 1354 "gas-token.c"
yy128:	yych = *++YYCURSOR;
	goto yy129;
yy129:
#line 549 "./modules/parsers/gas/gas-token.re"
{
            if (parser_gas->save_input)
                cursor = save_line(parser_gas, cursor);
            parser_gas->state = INITIAL;
            RETURN(s->tok[0]);
        }
#line 1365 "gas-token.c"
yy130:	yych = *++YYCURSOR;
	goto yy131;
yy131:
#line 556 "./modules/parsers/gas/gas-token.re"
{
            yasm_warn_set(YASM_WARN_UNREC_CHAR,
                          N_("ignoring unrecognized character `%s'"),
                          yasm__conv_unprint(s->tok[0]));
            goto section_directive;
        }
#line 1376 "gas-token.c"
yy132:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy133;
yy133:	if(yybm[0+yych] & 64) {
		goto yy132;
	}
	goto yy125;
yy134:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy135;
yy135:	if(yybm[0+yych] & 128) {
		goto yy134;
	}
	goto yy121;
}
}
#line 562 "./modules/parsers/gas/gas-token.re"


    /* filename portion of nasm preproc %line */
nasm_filename:
    strbuf = yasm_xmalloc(STRBUF_ALLOC_SIZE);
    strbuf_size = STRBUF_ALLOC_SIZE;
    count = 0;

nasm_filename_scan:
    SCANINIT();

    {
	static unsigned char yybm[] = {
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0, 128,   0,   0,   0, 128,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	128,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	  0,   0,   0,   0,   0,   0,   0,   0, 
	};

#line 1443 "gas-token.c"
{
	YYCTYPE yych;
	goto yy136;
	++YYCURSOR;
yy136:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych <= '\f'){
		if(yych <= '\b')	goto yy142;
		if(yych <= '\t')	goto yy140;
		if(yych >= '\v')	goto yy142;
		goto yy138;
	} else {
		if(yych <= '\r')	goto yy140;
		if(yych == ' ')	goto yy140;
		goto yy142;
	}
yy138:	yych = *++YYCURSOR;
	goto yy139;
yy139:
#line 574 "./modules/parsers/gas/gas-token.re"
{
            strbuf_append(count++, cursor, s, '\0');
            lvalp->str.contents = (char *)strbuf;
            lvalp->str.len = count;
            parser_gas->state = INITIAL;
            RETURN(STRING);
        }
#line 1472 "gas-token.c"
yy140:	yych = *++YYCURSOR;
	goto yy145;
yy141:
#line 582 "./modules/parsers/gas/gas-token.re"
{ goto nasm_filename_scan; }
#line 1478 "gas-token.c"
yy142:	yych = *++YYCURSOR;
	goto yy143;
yy143:
#line 584 "./modules/parsers/gas/gas-token.re"
{
            if (cursor == s->eof) {
                strbuf_append(count++, cursor, s, '\0');
                lvalp->str.contents = (char *)strbuf;
                lvalp->str.len = count;
                parser_gas->state = INITIAL;
                RETURN(STRING);
            }
            strbuf_append(count++, cursor, s, s->tok[0]);
            goto nasm_filename_scan;
        }
#line 1494 "gas-token.c"
yy144:	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	goto yy145;
yy145:	if(yybm[0+yych] & 128) {
		goto yy144;
	}
	goto yy141;
}
}
#line 595 "./modules/parsers/gas/gas-token.re"


    /* character constant values */
charconst:
    /*TODO*/

    /* string constant values */
stringconst:
    strbuf = yasm_xmalloc(STRBUF_ALLOC_SIZE);
    strbuf_size = STRBUF_ALLOC_SIZE;
    count = 0;

stringconst_scan:
    SCANINIT();

    {

#line 1523 "gas-token.c"
{
	YYCTYPE yych;
	goto yy146;
	++YYCURSOR;
yy146:
	if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if(yych == '"')	goto yy150;
	if(yych != '\\')	goto yy152;
	goto yy148;
yy148:	yych = *++YYCURSOR;
	if(yych == '"')	goto yy153;
	goto yy149;
yy149:
#line 632 "./modules/parsers/gas/gas-token.re"
{
            if (cursor == s->eof) {
                yasm_error_set(YASM_ERROR_SYNTAX,
                               N_("unexpected end of file in string"));
                lvalp->str.contents = (char *)strbuf;
                lvalp->str.len = count;
                RETURN(STRING);
            }
            strbuf_append(count++, cursor, s, s->tok[0]);
            goto stringconst_scan;
        }
#line 1550 "gas-token.c"
yy150:	yych = *++YYCURSOR;
	goto yy151;
yy151:
#line 624 "./modules/parsers/gas/gas-token.re"
{
            strbuf_append(count, cursor, s, '\0');
            yasm_unescape_cstring(strbuf, &count);
            lvalp->str.contents = (char *)strbuf;
            lvalp->str.len = count;
            RETURN(STRING);
        }
#line 1562 "gas-token.c"
yy152:	yych = *++YYCURSOR;
	goto yy149;
yy153:	yych = *++YYCURSOR;
	goto yy154;
yy154:
#line 612 "./modules/parsers/gas/gas-token.re"
{
            if (cursor == s->eof) {
                yasm_error_set(YASM_ERROR_SYNTAX,
                               N_("unexpected end of file in string"));
                lvalp->str.contents = (char *)strbuf;
                lvalp->str.len = count;
                RETURN(STRING);
            }
            strbuf_append(count++, cursor, s, '"');
            goto stringconst_scan;
        }
#line 1580 "gas-token.c"
}
}
#line 643 "./modules/parsers/gas/gas-token.re"


rept_directive:
    strbuf = yasm_xmalloc(STRBUF_ALLOC_SIZE);
    strbuf_size = STRBUF_ALLOC_SIZE;
    count = 0;
    linestart = 1;


rept_scan:
    SCANINIT();

    {

#line 1598 "gas-token.c"
{
	YYCTYPE yych;
	unsigned int yyaccept;
	goto yy155;
	++YYCURSOR;
yy155:
	if((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	if(yych <= '-'){
		if(yych != '\n')	goto yy161;
		goto yy157;
	} else {
		if(yych <= '.')	goto yy159;
		if(yych != ';')	goto yy161;
		goto yy157;
	}
yy157:	yych = *++YYCURSOR;
	goto yy158;
yy158:
#line 656 "./modules/parsers/gas/gas-token.re"
{
            /* Line ending, save in lines */
            new_line = yasm_xmalloc(sizeof(gas_rept_line));
            if (cursor == s->eof) {
                yasm_xfree(strbuf);
                return 0;
            }
            strbuf_append(count++, cursor, s, s->tok[0]);
            new_line->data = strbuf;
            new_line->len = count;
            STAILQ_INSERT_TAIL(&rept->lines, new_line, link);
            /* Allocate new strbuf */
            strbuf = yasm_xmalloc(STRBUF_ALLOC_SIZE);
            strbuf_size = STRBUF_ALLOC_SIZE;
            count = 0;
            /* Mark start of line */
            linestart = 1;
            goto rept_scan;
        }
#line 1638 "gas-token.c"
yy159:	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych <= 'R'){
		if(yych == 'E')	goto yy162;
		if(yych >= 'R')	goto yy164;
		goto yy160;
	} else {
		if(yych <= 'e'){
			if(yych >= 'e')	goto yy162;
			goto yy160;
		} else {
			if(yych == 'r')	goto yy164;
			goto yy160;
		}
	}
yy160:
#line 735 "./modules/parsers/gas/gas-token.re"
{
            if (cursor == s->eof) {
                yasm_xfree(strbuf);
                return 0;
            }
            strbuf_append(count++, cursor, s, s->tok[0]);
            linestart = 0;
            goto rept_scan;
        }
#line 1665 "gas-token.c"
yy161:	yych = *++YYCURSOR;
	goto yy160;
yy162:	yych = *++YYCURSOR;
	if(yych == 'N')	goto yy169;
	if(yych == 'n')	goto yy169;
	goto yy163;
yy163:	YYCURSOR = YYMARKER;
	switch(yyaccept){
	case 0:	goto yy160;
	}
yy164:	yych = *++YYCURSOR;
	if(yych == 'E')	goto yy165;
	if(yych != 'e')	goto yy163;
	goto yy165;
yy165:	yych = *++YYCURSOR;
	if(yych == 'P')	goto yy166;
	if(yych != 'p')	goto yy163;
	goto yy166;
yy166:	yych = *++YYCURSOR;
	if(yych == 'T')	goto yy167;
	if(yych != 't')	goto yy163;
	goto yy167;
yy167:	yych = *++YYCURSOR;
	goto yy168;
yy168:
#line 675 "./modules/parsers/gas/gas-token.re"
{
            int i;
            if (linestart) {
                /* We don't support nested right now, error */
                yasm_error_set(YASM_ERROR_GENERAL,
                               N_("nested rept not supported"));
                yasm_errwarn_propagate(parser_gas->errwarns, cur_line);
            }
            for (i=0; i<6; i++)
                strbuf_append(count++, cursor, s, s->tok[i]);
            goto rept_scan;
        }
#line 1704 "gas-token.c"
yy169:	yych = *++YYCURSOR;
	if(yych == 'D')	goto yy170;
	if(yych != 'd')	goto yy163;
	goto yy170;
yy170:	yych = *++YYCURSOR;
	if(yych == 'R')	goto yy171;
	if(yych != 'r')	goto yy163;
	goto yy171;
yy171:	yych = *++YYCURSOR;
	goto yy172;
yy172:
#line 687 "./modules/parsers/gas/gas-token.re"
{
            if (linestart) {
                /* We're done, kick off the main lexer */
                rept->line = STAILQ_FIRST(&rept->lines);
                if (!rept->line) {
                    /* Didn't get any intervening data?  Empty repeat, so
                     * don't even bother.
                     */
                    yasm_xfree(strbuf);
                    yasm_xfree(rept);
                    parser_gas->rept = NULL;
                } else {
                    rept->ended = 1;

                    /* Add .line as first line to get line numbers correct */
                    new_line = yasm_xmalloc(sizeof(gas_rept_line));
                    new_line->data = yasm_xmalloc(40);
                    sprintf((char *)new_line->data, ".line %lu;",
                            rept->startline+1);
                    new_line->len = strlen((char *)new_line->data);
                    STAILQ_INSERT_HEAD(&rept->lines, new_line, link);

                    /* Save previous fill buffer */
                    rept->oldbuf = parser_gas->s.bot;
                    rept->oldbuflen = s->lim - s->bot;
                    rept->oldbufpos = cursor - s->bot;

                    /* Reset fill */
                    s->bot = NULL;
                    s->tok = NULL;
                    s->ptr = NULL;
                    s->cur = NULL;
                    s->lim = NULL;
                    s->top = NULL;
                    s->eof = NULL;
                    cursor = NULL;
                    YYFILL(1);
                }

                goto scan;
            } else {
                int i;
                for (i=0; i<6; i++)
                    strbuf_append(count++, cursor, s, s->tok[i]);
                goto rept_scan;
            }
        }
#line 1764 "gas-token.c"
}
}
#line 744 "./modules/parsers/gas/gas-token.re"


}
